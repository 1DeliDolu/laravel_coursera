# ğŸ” DoÄŸru istek yÃ¶ntemleri

Bu kursta, Laravel iÃ§indeki istek mekanizmalarÄ±mÄ±zÄ± gÃ¼venli bir ÅŸekilde yapÄ±landÄ±rmayÄ± ele alacaÄŸÄ±m. AyrÄ±ca cross-site request forgery korumasÄ±nÄ± ve cross-site scriptingâ€™i Ã¶nlemek iÃ§in kullanÄ±cÄ± verisini escape etmeyi de anlatacaÄŸÄ±m. Bu videoda ise Laravel uygulamamÄ±zda doÄŸru istek yÃ¶ntemlerini kullanarak gÃ¼venli bir istek yaÅŸam dÃ¶ngÃ¼sÃ¼ geliÅŸtirmeye odaklanacaÄŸÄ±z. Ã–zellikle, burada ele alacaklarÄ±mÄ±z yaygÄ±n HTTP istekleri olacak; LDAP operasyon istekleri gibi egzotik ÅŸeyler ya da buna benzer baÅŸka ÅŸeyler deÄŸil. Sadece standart GET, POST, DELETE. Neyse, hemen konuya gireyim. Laravel, bÃ¼yÃ¼k ihtimalle ihtiyaÃ§ duyacaÄŸÄ±mÄ±z tÃ¼m istek metotlarÄ±nÄ± kullanabilmemizi saÄŸlar.

Ama birÃ§ok kez belirttiÄŸim gibi, varsayÄ±lan olarak standart, gÃ¼venli konfigÃ¼rasyonlarla gelir, yine de doÄŸru seÃ§imleri yaptÄ±ÄŸÄ±nÄ±zdan emin olmanÄ±z gerekir. Ä°lk yapmamÄ±z gereken, yaygÄ±n istek tÃ¼rlerini ve bunlarÄ± neden kullanabileceÄŸimizi anlamaktÄ±r.

Veri almak iÃ§in GET istek metodunu kullanacaÄŸÄ±z. Her ne kadar tÃ¼m istek metotlarÄ± sunucudan bir payload dÃ¶ndÃ¼rebilse de, GET metodu en Ã§ok veri almak istediÄŸimizi ifade eder. Ä°stek oldukÃ§a basittir. Temelde web Ã¼zerinde gezinirken tÄ±kladÄ±ÄŸÄ±nÄ±z tÃ¼m hyperlinkâ€™lerdir. PaylaÅŸÄ±labilirdir; yani birinin baÅŸka biriyle aynÄ± kaynaÄŸÄ± gÃ¶rmesini istiyorsanÄ±z, ona bir URL formunda bir GET isteÄŸi paylaÅŸabilirsiniz.

Ve cacheâ€™lenebilir. Cache servisleri, GET isteÄŸinin konfigÃ¼rasyonuna gÃ¶re cevaptan dÃ¶nen veriyi cacheâ€™leyebilir.

Veriyi manipÃ¼le etmeye, Ã¶zellikle yeni veri oluÅŸturma ve gÃ¼ncelleme iÅŸine geldiÄŸimizde POST, PUT ve PATCHâ€™e sahibiz. Ã‡oÄŸu kiÅŸi, POST metodunun tamamen yeni veri oluÅŸturmak iÃ§in kullanÄ±ldÄ±ÄŸÄ± konusunda hemfikirdir. Ancak, internetin Ã§ekirdek dokÃ¼mantasyonu olan RFCâ€™lerde, PUT ve PATCH arasÄ±ndaki iÅŸlevsellik konusunda bir miktar belirsizlik ya da daha doÄŸrusu, programcÄ±larÄ±n bunlarÄ± yorumlayÄ±ÅŸ biÃ§imlerinde farklÄ±lÄ±klar vardÄ±r. Bu uzun ve nÃ¼anslÄ± bir tartÄ±ÅŸma olabilir, fakat bu kurs iÃ§in benim gÃ¶rÃ¼ÅŸÃ¼me baÄŸlÄ± kalalÄ±m: POST oluÅŸturma iÃ§indir, PUT bir kaynaÄŸÄ±n tamamÄ±nÄ± gÃ¼ncellemek iÃ§indir ve PATCH yalnÄ±zca belirli kÄ±sÄ±mlarÄ± gÃ¼ncellemek, yani o kaynaÄŸÄ± â€œpatchâ€ etmek iÃ§indir.

Ã–yle ki, tarayÄ±cÄ± bu Ã¼Ã§ metodun yalnÄ±zca birini destekler: POST metodunu. Ancak HTTP veya REST tabanlÄ± APIâ€™lerin tÃ¼m bu metotlardan faydalandÄ±ÄŸÄ±nÄ± gÃ¶receksiniz. TarayÄ±cÄ±da Ã§alÄ±ÅŸan, kendi ortamÄ±nda bu istek metotlarÄ±nÄ±n herhangi birini gÃ¶nderebilen JavaScriptâ€™e sÄ±kÃ§a rastlarsÄ±nÄ±z. Bu istekler paylaÅŸÄ±labilir veya cacheâ€™lenebilir deÄŸildir. Bu da, isterseniz bir seviye daha gÃ¼venlik saÄŸlar. KÃ¶tÃ¼ amaÃ§lÄ± POST ya da PUT istekleri oluÅŸturamayacaÄŸÄ±nÄ±zÄ± sÃ¶ylemiyorum, kesinlikle oluÅŸturabilirsiniz, ama bunlarÄ± bir link ya da GET isteÄŸi gibi daÄŸÄ±tmak o kadar kolay deÄŸildir.

Son olarak, veri silmek iÃ§in DELETE metoduna sahipsiniz. Bu da tarayÄ±cÄ± tarafÄ±ndan doÄŸrudan desteklenmez, ancak APIâ€™lerde, tarayÄ±cÄ±da Ã§alÄ±ÅŸan JavaScriptâ€™te sÄ±klÄ±kla kullanÄ±lÄ±r.

POST isteklerinde olduÄŸu gibi, kolay bir ÅŸekilde paylaÅŸÄ±lmasÄ± veya cacheâ€™lenmesi mÃ¼mkÃ¼n deÄŸildir. Yine, bu bir adÄ±m daha zorlaÅŸtÄ±rÄ±lmÄ±ÅŸ demektir. Bu metodla back-endâ€™e bu kaynaÄŸÄ± silmek istediÄŸinizi belirtmek gÃ¼zeldir. Aksi halde ne yapardÄ±nÄ±z? Ne post ederdiniz? YÄ±llar Ã¶nce bÃ¶yle durumlara dÃ¼ÅŸtÃ¼m ve daha iyisini bilmiyorduk; IDâ€™leri post ediyorduk ve sonra DELETE gibi bir komut, neredeyse bir RPC ya da remote procedure call gibi davranÄ±yordu. Pek iyi deÄŸildi.

Peki, tÃ¼m bunlar Laravel ile nasÄ±l iliÅŸkili? Burada Web.php dosyamÄ±zdan route tanÄ±mlarÄ±mÄ±zÄ± gÃ¶steren bir alÄ±ntÄ± var. Ä°lk route girdisi, resourceful controller tanÄ±mÄ±dÄ±r. Bunu daha Ã¶nce de bahsetmiÅŸtim. Temelde, genel web iÅŸ akÄ±ÅŸÄ±yla eÅŸleÅŸen ve ilgili HTTP metotlarÄ±na sahip tÃ¼m bireysel routeâ€™larÄ± kÄ±sayoldan oluÅŸturmaktÄ±r. Bunun altÄ±nda ise, bu shorthand metodu kullanmadan, onun oluÅŸturacaÄŸÄ± ÅŸeyin ne olduÄŸunu elle tanÄ±mlamÄ±ÅŸ ÅŸekilde gÃ¶rebilirsiniz. Bireysel blog gÃ¶rÃ¼ntÃ¼leme sayfalarÄ±nÄ±n ve bunlara ait oluÅŸturma ve dÃ¼zenleme formlarÄ±nÄ±n sadece GET istekleri olduÄŸunu gÃ¶receksiniz.

Ama yeni bir tane oluÅŸturmaya geldiÄŸimizde bunu POST olarak tanÄ±mlayacaÄŸÄ±m. Ä°Ã§eriÄŸi gÃ¼ncellemek iÃ§in PATCH routeâ€™u ekledim ve Ã¶ÄŸeleri silmek iÃ§in de DELETE metodunu kullandÄ±m. Buradaki nokta ÅŸu: Paradigmlere uyup mimarimizde doÄŸru HTTP istek metotlarÄ±nÄ± kullandÄ±ÄŸÄ±mÄ±zda, aynÄ± ÅŸeyi doÄŸrudan Laravel iÃ§inde de yapabiliriz. AslÄ±nda Laravel bunu yapmamÄ±zÄ± istiyor, hatta sizin iÃ§in kÄ±sayollarÄ± da var. BÃ¶ylece controllerâ€™larÄ±nÄ±zdaki metotlarÄ±nÄ±z daha kÃ¼Ã§Ã¼k kalÄ±r ve yalnÄ±zca tek bir iÅŸi yapar; hangi tÃ¼r isteÄŸi ele aldÄ±klarÄ±nÄ± test etmek zorunda kalan o monolitik metotlardan olmaz. Daha az kod, daha az karmaÅŸÄ±klÄ±ktÄ±r; daha az karmaÅŸÄ±klÄ±k da daha az saldÄ±rÄ± vektÃ¶rÃ¼dÃ¼r.

Åimdi kendi kendinize dÃ¼ÅŸÃ¼nÃ¼yor olabilirsiniz, bu harika.

Ama az Ã¶nce tarayÄ±cÄ±nÄ±n yalnÄ±zca GET ve POSTâ€™u desteklediÄŸini sÃ¶ylemedin mi? PATCH ve DELETE formlarÄ±nÄ± nasÄ±l oluÅŸturacaÄŸÄ±m? BunlarÄ± sadece JavaScript ile AJAX istekleri olarak mÄ± yapmak zorundayÄ±m? HayÄ±r, deÄŸilsiniz. Laravel, formunuzda hangi metodu kullanmak istediÄŸinizi belirtmenize izin verir. Blade directiveâ€™i olan METHODâ€™u kullanarak formunuzda PUT, PATCH veya DELETE metodunu simÃ¼le edebilirsiniz. Bu Ã¶rnekte, blog girdim iÃ§in bir silme onay sayfasÄ± oluÅŸturdum.

Form deklarasyonu, blog entries controllerâ€™Ä±mdaki DELETE ya da DESTROY metoduna giden bir action kullanÄ±yor, fakat formun methodâ€™u POST. Bir sonraki satÄ±rda, blade directive olan methodâ€™u Ã§aÄŸÄ±rÄ±yor ve delete geÃ§iriyorum. Bu, tarayÄ±cÄ±ya isteÄŸi POST olarak gÃ¶ndermesini sÃ¶yleyecek. Yani paylaÅŸÄ±lmasÄ±, cacheâ€™lenmesi ya da kurcalanmasÄ± Ã§ok daha zor bir ÅŸey; ama Laravelâ€™e bunu bir DELETE isteÄŸi olarak iÅŸlemesini sÃ¶ylemiÅŸ oluyor. OldukÃ§a havalÄ±. ArtÄ±k bu mekanizmayÄ± kullanarak PUT, PATCH ve DELETE metotlarÄ±nÄ± belirtebilirsiniz.

DokÃ¼mantasyon, bunun Ã¶rneklerini POST metodu kullanÄ±larak, yani bir formda gÃ¶steriyor.

Ama â€œmutlaka POST olmalÄ±dÄ±râ€ diyebilir, ya da belki demiyordur. O yÃ¼zden, kodu gÃ¼venlik aÃ§Ä±sÄ±ndan incelemek gibi iÅŸler yaparken, aynÄ± zamanda onu gerÃ§ekten anladÄ±ÄŸÄ±mdan emin olmak iÃ§in denemeler yapmayÄ± da seviyorum. Kendi kendime ÅŸunu merak ediyorum: Bu POST metoduyla mÄ± sÄ±nÄ±rlÄ±? Ben bunu bozabilir miyim? Birazdan yapacaÄŸÄ±m demo iÃ§in kurulum ÅŸu ÅŸekilde: Bir kÃ¶peÄŸi dÃ¼zenlemek iÃ§in bir edit formu gÃ¶steren bir controllerâ€™Ä±m var. KÃ¶peÄŸin adÄ±nÄ± deÄŸiÅŸtirebiliyorum. AyrÄ±ca burada, gelen deÄŸiÅŸiklik verisini kabul eden, bir kÃ¶peÄŸe uygulayan ve baÅŸarÄ±lÄ± olduÄŸuna dair bir mesajla redirect eden PATCH metoduna da sahibim.

Hadi ÅŸimdi bunlarÄ±n bir kÄ±smÄ±nÄ± Ã§alÄ±ÅŸÄ±rken gÃ¶relim. Burada, bu dog kaynaÄŸÄ±nÄ± patch etmek istediÄŸimi belirtmek iÃ§in method blade directiveâ€™ini kullandÄ±ÄŸÄ±m standart bir formumuz var. AdÄ± deÄŸiÅŸtireceÄŸim. Yeni bir ad seÃ§eyim ve sonra bu formu POST olarak submit edeyim; bu, Laravelâ€™e bir PATCH isteÄŸini simÃ¼le edecek ve dÃ¼zenlenmiÅŸ olacak. GÃ¼zel. Ama bir fikrim var: EÄŸer bu blade directiveâ€™i bir POST iÅŸlemi yaparken back-endâ€™e bir ÅŸey gÃ¶nderiyorsa, bunu alÄ±p bir PATCH isteÄŸini simÃ¼le etmek iÃ§in GET isteÄŸi haline getiremez miyim? EÄŸer yapabilseydim, bu bÃ¼yÃ¼k bir hayÄ±r olurdu. Åimdi, bunu yapÄ±p yapamayacaÄŸÄ±mÄ± gÃ¶rmek istiyorum.

Formun yeni bir versiyonunu alayÄ±m, sadece sayfayÄ± yenileyeceÄŸim ve sonra formu inceleyeceÄŸim. Burada, method blade directiveâ€™inin yalnÄ±zca adÄ± underscore method (_method) ve deÄŸeri patch olan gizli bir input Ã¼rettiÄŸini gÃ¶rebiliyorum. KÃ¶pek ismi inputâ€™unun adÄ± ise name. Neden bu bilgilerle bir GET isteÄŸi oluÅŸturmayÄ± denemeyeyim ki? Ne yaptÄ±ÄŸÄ±mÄ± sizin daha kolay gÃ¶rmeniz iÃ§in, kodu inspector iÃ§inde yerinde dÃ¼zenleyeceÄŸim. Bu formun submit edeceÄŸi URLâ€™ye, method parametresini ve name parametresini ekleyen bir GET isteÄŸi oluÅŸturacak bir A etiketi yapacaÄŸÄ±m. Bu, GET isteÄŸimizi oluÅŸturacak ve bunun da POST simÃ¼lasyonu gibi Ã§alÄ±ÅŸacaÄŸÄ±nÄ± varsayardÄ±m.

DiÄŸer tarafa geÃ§ip tÄ±klayacaÄŸÄ±m. Temelde hiÃ§bir ÅŸey olmadÄ±. Beni tekrar edit formuna geri gÃ¶tÃ¼rdÃ¼ ve hiÃ§bir ÅŸey deÄŸiÅŸmedi.

Bunun sebebi, bu form iÃ§in URLâ€™den gelen isteÄŸi bir GET isteÄŸi olarak tanÄ±masÄ±ydÄ±. Yani bu mantÄ±klÄ±. Belki de bu GET isteÄŸi, simÃ¼le ettiÄŸim PATCH isteÄŸinden daha yÃ¼ksek Ã¶nceliÄŸe sahipti. O zaman diÄŸer ekrana geÃ§ip web.php dosyamÄ± dÃ¼zenleyeceÄŸim, bÃ¶ylece yalnÄ±zca ÅŸu tek patch routeâ€™u kalacak ÅŸekilde GET tanÄ±mÄ±nÄ± kaldÄ±racaÄŸÄ±m.

Sonra az Ã¶nce oluÅŸturduÄŸum Ã¶zelleÅŸtirilmiÅŸ URL ile sayfayÄ± yenileyeceÄŸim. HayÄ±r, yine Ã§alÄ±ÅŸmÄ±yor. â€œYalnÄ±zca PATCH destekleniyorâ€ diyor. Laravel, simÃ¼le edilmiÅŸ bir metod kullandÄ±ÄŸÄ±mda bunun yalnÄ±zca bir POST isteÄŸinden gelebileceÄŸini, herhangi biriyle paylaÅŸtÄ±ÄŸÄ±m bir linkten olamayacaÄŸÄ±nÄ± bilecek kadar gÃ¼venli bir ÅŸekilde konfigÃ¼re edilmiÅŸ ve yeterince akÄ±llÄ±. Bu, PUT, PATCH, DELETE ve POST metotlarÄ±mÄ±zÄ± gÃ¼vence altÄ±na almanÄ±n yalnÄ±zca bir adÄ±mÄ±. DiÄŸeri ise cross-site request forgeryâ€™leri durdurmak; bunu da bir sonraki videoda konuÅŸacaÄŸÄ±z.
