# ğŸ—‚ï¸ Session kurulumu

Bu derste hem sessions hem de cookies konularÄ±nÄ± ele alacaÄŸÄ±z. Bu ikisi birlikte ele alÄ±nÄ±yor Ã§Ã¼nkÃ¼ aslÄ±nda bir kullanÄ±cÄ± hakkÄ±nda bildiÄŸimiz bazÄ± bilgileri kalÄ±cÄ± hÃ¢le getirmenin iki farklÄ± yÃ¶nteminden ibaretler. Ä°lk olarak, bu videoda sessions Ã¼zerinde duralÄ±m. OnlarÄ± nasÄ±l kullandÄ±ÄŸÄ±mÄ±za geÃ§meden Ã¶nce, sessionsâ€™Ä±n gerÃ§ekte ne olduÄŸunu hepimizin aynÄ± ÅŸekilde anladÄ±ÄŸÄ±ndan emin olalÄ±m. Sessions, temelde bir ziyaretÃ§inin seÃ§imleri veya HTTP istekleri arasÄ±nda kalÄ±cÄ± olmasÄ±nÄ± istediÄŸimiz eylemleri hakkÄ±ndaki bilgileri sakladÄ±ÄŸÄ±mÄ±z bir depolama mekanizmasÄ±dÄ±r. Ã‡Ã¼nkÃ¼ unutmayÄ±n, HTTP istekleri birbirinden baÄŸÄ±msÄ±zdÄ±r ve kendi iÃ§inde herhangi bir state barÄ±ndÄ±rmaz. Sessionâ€™Ä± tanÄ±mlamak iÃ§in ziyaretÃ§iye Ã¶zel benzersiz bir ID kullanÄ±lÄ±r.

Bu ID o kadar benzersizdir ki birinin bunu tahmin etmesi oldukÃ§a zordur. Bu, bunun hiÃ§bir zaman olamayacaÄŸÄ± anlamÄ±na gelmez; yeterince zaman veya ÅŸans ile olabilir â€” ama bunu biraz sonra nasÄ±l Ã§Ã¶zeceÄŸimizden bahsedeceÄŸiz. Bu ID, cookies ile birlikte gÃ¶nderilir. Temel mantÄ±k ÅŸudur: Session ID, ziyaretÃ§inin ilk sayfa ziyaretinde ona cookie olarak gÃ¶nderilir. ZiyaretÃ§i bu cookieâ€™yi saklar ve her istekte geri gÃ¶ndererek aynÄ± kullanÄ±cÄ± olduÄŸunu belirtir. BazÄ± durumlarda session ID, istek ile farklÄ± bir header Ã¼zerinden de gÃ¶nderilebilir veya eskiden get query parametresiyle bile gÃ¶nderilebiliyordu. Ancak bunu yÃ¶netmenin karmaÅŸÄ±klÄ±ÄŸÄ± ve URL Ã¼zerinde tamamen gÃ¶rÃ¼nÃ¼r olmasÄ± nedeniyle artÄ±k pek kullanÄ±lmÄ±yor.

Sessions, kullanÄ±cÄ± tarafÄ±nda kÃ¼Ã§Ã¼k verilerden oluÅŸur, temelde sadece bir ID iÃ§erir. Ancak server tarafÄ±nda daha bÃ¼yÃ¼ktÃ¼r; yani kullanÄ±cÄ± hakkÄ±nda gÃ¼venli bir ortamda daha fazla bilgi saklarÄ±z. Bu Ã¶nemlidir Ã§Ã¼nkÃ¼ istemci tarafÄ±nda yÃ¶netmemiz gereken tek gizli ÅŸey session IDâ€™dir. Oysa server tarafÄ±nda kullanÄ±cÄ±ya dair faydalÄ± bilgilerin sayÄ±sÄ± daha fazla olabilir; bunlar gÃ¼venlidir ve hatta bazen daha Ã¶nemlisi, kullanÄ±cÄ± tarafÄ±ndan deÄŸiÅŸtirilemez. Laravelâ€™in session handlerâ€™Ä± bu en iyi uygulamalardan birÃ§oÄŸunu kullanÄ±r, ancak bazen kendi unique session handling mekanizmanÄ±zÄ± yazmanÄ±z veya Laravel uygulamasÄ±nÄ± standart bir PHP uygulamasÄ±yla karÄ±ÅŸtÄ±rmanÄ±z gerekebilir. Bu yÃ¼zden birkaÃ§ best practiceâ€™den bahsedelim. Benzersiz IDâ€™yi periyodik olarak dÃ¶ndÃ¼rmek isteriz.

Bunu yeni bir session baÅŸlatmakla karÄ±ÅŸtÄ±rmayÄ±n. HÃ¢lÃ¢ aynÄ± session bilgisini kullanÄ±yoruz, sadece Identifier deÄŸiÅŸiyor. Bu sayede ziyaretÃ§i bilgilerini koruyoruz ama session IDâ€™nin tahmin edilmesi iÃ§in gereken sÃ¼reyi sÄ±fÄ±rlÄ±yoruz veya ele geÃ§irilmiÅŸ bir IDâ€™yi geÃ§ersiz hÃ¢le getiriyoruz. GÃ¶rdÃ¼ÄŸÃ¼m bir ÅŸey, bazÄ± uygulamalarÄ±n remember me iÅŸlevi saÄŸlamak iÃ§in Ã§ok uzun session sÃ¼releri kullanmasÄ±. Yani kullanÄ±cÄ± dÃ¶rt gÃ¼n sonra geri gelirse tekrar giriÅŸ yapmasÄ±nÄ± istemiyoruz. Ama session sÃ¼remiz sadece iki saatse bunu nasÄ±l yapacaÄŸÄ±z? Session sÃ¼relerini uzatmak doÄŸru Ã§Ã¶zÃ¼m deÄŸil. Bunun yerine bir remember me fonksiyonu kullanÄ±n.

Laravel, login veya authentication kit kullanÄ±yorsanÄ±z bunu zaten dahili olarak saÄŸlar. Ancak burada Ã¶nemli olan ÅŸey ÅŸudur: GÃ¼Ã§lÃ¼ bir IDâ€™yi sonsuza kadar saklamak istemezsiniz. Remember me token ile bu ID tek seferlik olarak yeni bir session ile takas edilir. Bu, remember me tokenâ€™Ä±nÄ±n uzun sÃ¼re saklanabilmesine raÄŸmen sadece bir kez geÃ§erli olduÄŸu anlamÄ±na gelir; her istekte yeniden kullanÄ±lmaz. Temel fikir ÅŸudur: Bir ÅŸey daha uzun sÃ¼re saklanabiliyorsa, sadece bir kez geÃ§erli olmalÄ±dÄ±r. AyrÄ±ca, web uygulamamÄ±zda pseudo benzeri eriÅŸim seviyesi deÄŸiÅŸikliklerinde session IDâ€™yi deÄŸiÅŸtirmek isteriz. Ya da bir kullanÄ±cÄ± siteyi ziyaret ederken oturum aÃ§tÄ±ÄŸÄ±nda, authenticated olmayan bir session IDâ€™nin authenticated state iÃ§in geÃ§erli olmamasÄ± gerekir.

Genel olarak, authenticated olmayan kod alanlarÄ± daha az korunur ve veri sÄ±zÄ±ntÄ±sÄ±na daha aÃ§Ä±ktÄ±r. Session verilerini kÃ¼Ã§Ã¼k tutun; session ID kadar kÃ¼Ã§Ã¼k olmayabilir ama yine de kÃ¼Ã§Ã¼k olmasÄ±nÄ± isteriz. Session her baÅŸlatÄ±ldÄ±ÄŸÄ±nda bu veriyi hydrate etmemiz, unserialize etmemiz ve hafÄ±zada tutmamÄ±z gerekir. Bu verinin kÃ¼Ã§Ã¼k olmasÄ± daha hÄ±zlÄ± ve verimli bir iÅŸlem saÄŸlar. AyrÄ±ca session verilerinin daha uzun Ã¶mÃ¼rlÃ¼ persistent verilere iÅŸaretÃ§iler olmasÄ± sayesinde, o veri deÄŸiÅŸtiÄŸinde sessionâ€™Ä± sÃ¼rekli gÃ¼ncellemek zorunda da kalmayÄ±z; sadece iÅŸaret ederiz. Session, kullanÄ±cÄ± hakkÄ±nda on farklÄ± ÅŸeye iÅŸaret eden veriler iÃ§eriyor olabilir, ancak bir request iÃ§in belki sadece bir tanesi gerÃ§ekten gerekli olacaktÄ±r. Laravel session yapÄ±landÄ±rmasÄ± config/session.php dosyasÄ±nda yapÄ±lÄ±r.

Laravel sessions, sadece PHP sessionsâ€™tÄ±r ancak sarÄ±lmÄ±ÅŸ hÃ¢lidir, bu yÃ¼zden custom session wrappers konusunda bÃ¼yÃ¼k bir esneklik saÄŸlar. Laravel, file, cookie, database, redis, dynamodb ve array driverâ€™larÄ±nÄ± saÄŸlar. VarsayÄ±lan ve en popÃ¼ler yapÄ±landÄ±rmalardan biri file driverâ€™dÄ±r. Bu, session verilerini sunucunun yerel dosya sisteminde depolar. Ã‡oÄŸu uygulama iÃ§in yeterince hÄ±zlÄ± ve uygundur. Ancak birden fazla web sunucunuz varsa database veya redis gibi bir driverâ€™a geÃ§mek isteyebilirsiniz. Birden fazla sunucu demek birden fazla dosya sistemi demektir ve sticky load balancing yoksa her istekte farklÄ± bir sunucuya dÃ¼ÅŸebilir ve session kaybolabilir.

BirÃ§ok programcÄ±dan en Ã§ok duyduÄŸum sorulardan biri: â€œFile mÄ± yoksa database sessions mÄ± daha gÃ¼venli?â€ AslÄ±nda bunu bir soru hÃ¢line ben getiriyorum; Ã§Ã¼nkÃ¼ Ã§oÄŸu zaman bana sÃ¶ylenen ÅŸey ÅŸu oluyor: â€œDatabase session handler kullan, Ã§Ã¼nkÃ¼ dosyalar gÃ¼vensiz.â€ Ancak derine indiÄŸinizde bu argÃ¼manÄ± destekleyen pek bir ÅŸey yok. Bunun en bÃ¼yÃ¼k nedeni bence geÃ§miÅŸte PHP uygulamalarÄ±nÄ±n shared server Ã¼zerinde barÄ±ndÄ±rÄ±lmasÄ± ve session dosya sisteminin mÃ¼ÅŸteriler arasÄ±nda paylaÅŸÄ±lÄ±yor olmasÄ±ydÄ±. Eskiden ben bile shared session viewer yazÄ±p insanlarÄ±n birbirlerinin session verilerini nasÄ±l okuyabileceÄŸini gÃ¶stermek iÃ§in kullanÄ±rdÄ±m. Ama birkaÃ§ ÅŸeyi gÃ¶z Ã¶nÃ¼nde bulundurmalÄ±yÄ±z.

Ä°lk olarak, artÄ±k birÃ§ok Laravel uygulamasÄ± kendi yÃ¶netilen sunucusunda, VPSâ€™te veya bir container iÃ§inde barÄ±ndÄ±rÄ±lÄ±yor. AyrÄ±ca shared hosting saÄŸlayÄ±cÄ±larÄ± da Ã§ok daha gÃ¼venli yapÄ±landÄ±rmalar kullanÄ±yor. Ama yine de bÃ¶yle bir ortamdaysanÄ±z Laravel session file save path deÄŸerini config Ã¼zerinden kendinize Ã¶zel bir dizine Ã§ekebilirsiniz. Session save path PHPâ€™de veya .ini ayarÄ±nda da tanÄ±mlanabilir. Yani session dosyalarÄ±nÄ± izinlerini kontrol ettiÄŸiniz bir dizine koyabilirsiniz. Ã–zet: Session dosyalarÄ±nÄ±n konumunu yapÄ±landÄ±rmadan deÄŸiÅŸtirebilirsiniz. Bir diÄŸer argÃ¼man da ÅŸu: Bir saldÄ±rgan session dosyalarÄ±nÄ±za eriÅŸebiliyorsa muhtemelen source codeâ€™unuzu da okuyabilir. Bu durumda environment deÄŸerlerinizi ve database eriÅŸiminizi de gÃ¶rebilir.

Yani database, sadece bir adÄ±m daha ileride. Son olarak Laravel session verilerini de ÅŸifreler. Bu da ele geÃ§irilmesi durumunda verinin Ã§Ã¶zÃ¼lmesini daha da zorlaÅŸtÄ±rÄ±r. SonuÃ§ olarak, hangi implementasyon daha gÃ¼venli diye Ã§ok takÄ±lmayÄ±n; uygulamanÄ±zÄ±n ihtiyaÃ§larÄ±na uyanÄ± ve karmaÅŸÄ±klÄ±ÄŸÄ± azaltanÄ± kullanÄ±n. UnutmayÄ±n, uygulamamÄ±zda ne kadar Ã§ok karmaÅŸÄ±klÄ±k varsa yanlÄ±ÅŸ yapÄ±landÄ±rma ve gÃ¼venlik aÃ§Ä±ÄŸÄ± bÄ±rakma riskimiz de o kadar artar.

TÃ¼m bunlarÄ± sÃ¶yledikten sonra, Laravelâ€™in file driverâ€™Ä± ile session kurmak oldukÃ§a basit. Peki database driver nasÄ±l? Biraz daha karmaÅŸÄ±k. Ä°lk adÄ±m, env dosyamÄ±zda session driver deÄŸiÅŸkenini ayarlamak. Bunun config/session.php dosyasÄ±na nasÄ±l aktarÄ±ldÄ±ÄŸÄ±nÄ± gÃ¶rebilirsiniz; file driver da bir fallback olarak durur. Yani sessionâ€™Ä± database kullanacak ÅŸekilde yapÄ±landÄ±rdÄ±k. Peki bunu kurmak ve Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸrulamak iÃ§in baÅŸka hangi adÄ±mlar gerekli?

Sessionâ€™Ä± database iÃ§in yapÄ±landÄ±rdÄ±ÄŸÄ±mÄ±za gÃ¶re artisan komutu session tableâ€™Ä± kullanarak gerekli tabloyu oluÅŸturacak migrationâ€™Ä± oluÅŸturabiliriz. Åimdi bunun ne oluÅŸturduÄŸuna bakalÄ±m.

Sadece id, user ID (opsiyonel), IP address, user agent, payload ve last activity iÃ§eren basit bir tablo oluÅŸturur. Bu aslÄ±nda file based session kullanÄ±rken kutudan Ã§Ä±ktÄ±ÄŸÄ± hÃ¢liyle her zaman elde etmediÄŸiniz biraz ekstra bilgi saÄŸlar. Bu gÃ¼zel. Åimdi migrationâ€™Ä± Ã§alÄ±ÅŸtÄ±ralÄ±m. ArdÄ±ndan tinkerâ€™a girerek sessions tablosuna bakalÄ±m. BeklediÄŸimiz gibi hiÃ§bir ÅŸey yok. ZiyaretÃ§i iÃ§in session baÅŸlatan ve her seferinde sessionâ€™a rastgele bir kelime ekleyen ufak bir kod ayarladÄ±m.

SayfayÄ± birkaÃ§ kez yenileyelim ve sessionâ€™a yeni rastgele kelimeler ekleyelim. Tinkerâ€™a dÃ¶ndÃ¼ÄŸÃ¼mÃ¼zde artÄ±k session tablosunda veri olduÄŸunu gÃ¶rebilirsiniz. Payload kÄ±smÄ± gÃ¼zelce ÅŸifrelenmiÅŸ, ancak gerÃ§ekte ziyaretÃ§iye ait rastgele kelimeyi temsil ediyor. Arka planda baÅŸka bir tarayÄ±cÄ± aÃ§Ä±p birkaÃ§ kez yeniliyorum. Tinkerâ€™a dÃ¶ndÃ¼ÄŸÃ¼mde artÄ±k iki session girdisi olduÄŸunu gÃ¶rÃ¼yorsunuz. ArtÄ±k uygulamamÄ±z session verisi iÃ§in MySQL database kullanacak ÅŸekilde yapÄ±landÄ±rÄ±ldÄ± ve yapÄ±landÄ±rmamÄ±zÄ±n beklendiÄŸi gibi Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± doÄŸruladÄ±k.
