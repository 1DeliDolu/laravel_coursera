# ğŸ§© Session manipÃ¼lasyonu

ArtÄ±k bir sessionâ€™Ä± nasÄ±l yapÄ±landÄ±racaÄŸÄ±mÄ±zÄ± ve kuracaÄŸÄ±mÄ±zÄ± konuÅŸtuÄŸumuza gÃ¶re, iÃ§indeki veriyi yÃ¶netmekten bahsedelim. AÅŸaÄŸÄ±daki Ã¶rneklerde bir iletiÅŸim formu gÃ¶nderme senaryosu Ã¼zerinden ilerleyeceÄŸim. Ã–rneÄŸimizde her departman iÃ§in birkaÃ§ landing page var ve biri bu landing pageâ€™lerden birindeki contact baÄŸlantÄ±sÄ±na tÄ±klarsa, nereden geldiklerini bilmek istiyoruz. Form gÃ¶nderildiÄŸinde, iletiÅŸim formu verilerini daha sonra kullanÄ±lmak Ã¼zere kaydedeceÄŸiz ve uygun departmanlara uygun bildirimleri gÃ¶nderecek bir job dispatch edeceÄŸiz. Son olarak, iletiÅŸim formunda seÃ§tikleri subjectâ€™e gÃ¶re Ã¶zelleÅŸtirilmiÅŸ bir veri iÃ§eren bir baÅŸarÄ± sayfasÄ± gÃ¶stereceÄŸiz. Ancak form gÃ¶ndermemiÅŸ hiÃ§ kimseye bu baÅŸarÄ± sayfasÄ±nÄ± gÃ¶stermek istemiyoruz.

Oturum verisini retrieve etmeye, yani almaya baÅŸlayalÄ±m. Sessions, requestâ€™in bir parÃ§asÄ±dÄ±r, bu nedenle controller iÃ§inde gÃ¶rebileceÄŸiniz gibi request instanceâ€™Ä±nda session metodu bulunur. Session instanceâ€™Ä± Ã¼zerinde GET metodunu Ã§aÄŸÄ±rmak, session store iÃ§indeki belirli bir keyâ€™i getirir. ArdÄ±ndan bu veriyi view iÃ§ine gÃ¶nderebiliriz. SaÄŸ taraftaki controllerâ€™da kÃ¼Ã§Ã¼k bir deÄŸiÅŸiklik gÃ¶rÃ¼rsÃ¼nÃ¼z. Global bir session metodu da mevcuttur. Bu metodun ilk parametresine key vererek doÄŸrudan veri alabilirsiniz.

Åimdi session iÃ§ine veri set etmeyi konuÅŸalÄ±m. Tekrar request Ã¼zerinden sessionâ€™a eriÅŸip PUT metodunu Ã§aÄŸÄ±rarak bunu yapabiliriz. Ä°lk Ã¶rnekte validated dataâ€™yÄ± alÄ±yoruz, bir contact form oluÅŸturuyoruz, bir job dispatch ediyoruz ve ardÄ±ndan sessionâ€™a contact topic adlÄ± bir key ile validated dataâ€™dan gelen deÄŸeri koyuyoruz. Sonra success sayfasÄ±na yÃ¶nlendiriyoruz. SaÄŸ tarafta aynÄ± controller var ancak burada veriyi set etmek iÃ§in global session metodunu kullandÄ±ÄŸÄ±mÄ±zÄ± gÃ¶rebilirsiniz. Bu ÅŸekilde kullanmak iÃ§in bir array gÃ¶ndermeniz gerekir: arrayâ€™in keyâ€™i session verisinin keyâ€™idir, value ise kaydetmek istediÄŸiniz veridir. Bu yÃ¶ntemi kafa karÄ±ÅŸtÄ±rÄ±cÄ± bulduÄŸumu sÃ¶ylemeliyim ve zorunda olmadÄ±kÃ§a global metotlarÄ± kullanmayÄ± sevmiyorum. Request session metodunu kullanmak Ã§ok daha anlaÅŸÄ±lÄ±r.

Burada sessionâ€™da veri olup olmadÄ±ÄŸÄ±nÄ± nasÄ±l kontrol edeceÄŸimize ve bir veriyi yalnÄ±zca bir kez nasÄ±l retrieve edeceÄŸimize bakacaÄŸÄ±z. Solda controllerâ€™Ä±n success metodunu gÃ¶rebilirsiniz. Ä°lk olarak request instanceâ€™Ä± Ã¼zerinden session metodunu tekrar Ã§aÄŸÄ±rÄ±rÄ±z ve ardÄ±ndan has() metoduyla sessionâ€™da bir key olup olmadÄ±ÄŸÄ±nÄ± ve boÅŸ olmadÄ±ÄŸÄ±nÄ± kontrol ederiz. Kodda â€œeÄŸer yoksaâ€ contact sayfasÄ±na yÃ¶nlendir diyor. ArdÄ±ndan sessionâ€™dan contact topicâ€™i Ã§ekebiliriz. Pull, GET gibi Ã§alÄ±ÅŸÄ±r ancak veriyi aldÄ±ktan sonra sessionâ€™dan siler. Bu sayfayÄ± yalnÄ±zca bir kez ve yalnÄ±zca form gÃ¶nderildikten sonra gÃ¶stermek istediÄŸimiz iÃ§in, pull ile veriyi alÄ±p kaldÄ±rmak mantÄ±klÄ± olur.

SaÄŸ tarafta has()â€™in tersi olan missing() metodunu gÃ¶rÃ¼rsÃ¼nÃ¼z. Laravelâ€™de Boolean dÃ¶nen birÃ§ok metodun bir alternatifi vardÄ±r. Bu da success metodunun baÅŸÄ±ndaki kodu yazmanÄ±n baÅŸka bir yoludur. Sessionâ€™dan veri silmek oldukÃ§a kolaydÄ±r. Request session instanceâ€™Ä± Ã¼zerinden forget() metodunu Ã§aÄŸÄ±rarak belirli bir keyâ€™i silebilirsiniz. KullanÄ±cÄ± sessionâ€™Ä±ndaki tÃ¼m veriyi kaldÄ±rmak iÃ§in flush metodunu kullanabilirsiniz.

Son olarak, flash mekanizmasÄ±nÄ± kullanarak sessionâ€™a yalnÄ±zca bir isteklik veri set edebilirsiniz. Bu, iletiÅŸim formu Ã¶rneÄŸinde baÅŸka bir yÃ¶ntem olabilirdi. Veriyi saklamak yerine topicâ€™i sessionâ€™a flash edebilirdim, bÃ¶ylece pullâ€™a gÃ¼venmek zorunda kalmazdÄ±m. SaÄŸ tarafta flash metodunun en yaygÄ±n kullanÄ±mÄ±nÄ± gÃ¶rÃ¼rsÃ¼nÃ¼z. Ã‡oÄŸu zaman bir iÅŸlem tamamlandÄ±ktan sonra â€” Ã¶rneÄŸin gÃ¼ncelleme iÅŸlemi â€” bir index metoduna success mesajÄ±yla yÃ¶nlendirilir. Redirect instanceâ€™Ä±ndaki with() metodu, sessionâ€™a bir key ve value flash etmenizi saÄŸlar. Genellikle index pageâ€™lerin viewâ€™larÄ± bu session keyâ€™i kontrol eder ve set edilmiÅŸse mesajÄ± gÃ¶sterir.

Flashâ€™lersiniz Ã§Ã¼nkÃ¼ sayfa yenilendiÄŸinde tekrar tekrar gÃ¶sterilmesini istemezsiniz. Laravel session IDâ€™yi yeniden Ã¼retmek, login veya authentication kitlerinden birini kullanmÄ±yorsanÄ±z yapÄ±lmalÄ±dÄ±r. BÃ¶yle bir durumda, kullanÄ±cÄ± authenticate edildikten sonra session IDâ€™yi regenerate etmelisiniz. Aksi hÃ¢lde, login kitleri bunu otomatik yapar. Bir kullanÄ±cÄ±nÄ±n parolasÄ±nÄ± deÄŸiÅŸtirdiÄŸinde de sessionâ€™Ä± regenerate etmenin iyi bir fikir olduÄŸunu dÃ¼ÅŸÃ¼nÃ¼yorum. Parola deÄŸiÅŸtirmek kullanÄ±cÄ±nÄ±n gÃ¼venlik planÄ±nÄ±n bir parÃ§asÄ±dÄ±r; eski session IDâ€™sine sahip birisinin hÃ¢lÃ¢ sessionâ€™a eriÅŸebilmesini istemeyiz. AyrÄ±ca kullanÄ±cÄ±ya daha yÃ¼ksek ayrÄ±calÄ±k saÄŸlayan bir fonksiyonun Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± durumunda da IDâ€™yi yeniden Ã¼retin.

Session bilgisini tamamen sÄ±fÄ±rlamak isterseniz invalidate metodunu Ã§aÄŸÄ±rabilirsiniz. Bu, tÃ¼m kullanÄ±cÄ± verisini sessionâ€™dan kaldÄ±rÄ±r ve IDâ€™yi yeniden Ã¼retir. Bunu Ã§ok sÄ±k yaptÄ±ÄŸÄ±mÄ± sÃ¶yleyemem Ã§Ã¼nkÃ¼ Laravel bunu logout sÄ±rasÄ±nda kendisi halleder. CSRF korumasÄ± iÃ§in yeni bir token Ã¼retmeniz gerekiyorsa regenerate token metodunu kullanabilirsiniz. Bunun hakkÄ±nda daha fazla konuÅŸacaÄŸÄ±z.

Sessionâ€™lar bu kadar. Laravelâ€™in gÃ¼Ã§lÃ¼ session aracÄ± size yÃ¶netim, depolama, ÅŸifreleme ve session lifecycleâ€™Ä±nÄ± gÃ¼venli ve etkili biÃ§imde yÃ¶netmek iÃ§in pek Ã§ok seÃ§enek sunar â€” Ã¶zellikle de authentication kitlerini kullanÄ±yorsanÄ±z.
